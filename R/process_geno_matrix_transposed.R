#' Process Genotype Data into Centered Coefficient Matrices for insilico_transposed Output
#'
#' Reads genotype data from a CSV file generated by insilico_transposed (hybrids as rows, markers as columns),
#' filters markers based on minor allele count, centers genotypes around mean allele frequencies,
#' and optionally computes dominance coefficients. Results are stored in disk-based \code{big.matrix} objects.
#' Chunks are processed in parallel across multiple cores for efficiency.
#'
#' @param filename Character string specifying the path to the CSV file containing genotype data
#'   (hybrids as rows, markers as columns). The file must include a header with "hybrid" as the first column
#'   followed by marker columns.
#' @param ploidy Integer specifying the ploidy level (e.g., 2 for diploid, 4 for tetraploid).
#'   Must be a positive even number.
#' @param dominance Logical indicating whether to compute dominance coefficients in addition to additive coefficients.
#'   If \code{TRUE}, a second \code{big.matrix} is created for dominance effects. Defaults to \code{FALSE}.
#' @param chunk_size Integer specifying the number of hybrids to process in each chunk.
#'   Adjust this to balance memory usage and performance. Defaults to 125000.
#' @param min_minor_allele Integer specifying the minimum number of hybrids carrying the minor allele
#'   required for a marker to be retained after filtering. Defaults to 5.
#'
#' @return A list containing:
#'   \itemize{
#'     \item \code{coeff}: A \code{big.matrix.descriptor} pointing to the disk-based matrix of centered genotype coefficients
#'       (rows = hybrids, columns = markers).
#'     \item \code{coeff.D}: A \code{big.matrix.descriptor} for dominance coefficients (only included if \code{dominance = TRUE}).
#'     \item \code{id}: A character vector of hybrid IDs.
#'     \item \code{markers}: A character vector of kept marker names.
#'   }
#'
#' @details
#' The function processes the input CSV in two passes, parallelizing chunks across multiple CPU cores:
#' \enumerate{
#'   \item \strong{First pass}: Reads the CSV in chunks of hybrids to compute per-marker statistics (sum, count, minor allele counts)
#'     and filters markers based on \code{min_minor_allele}.
#'   \item \strong{Second pass}: Reads the CSV again to compute centered genotype coefficients (and dominance coefficients if requested)
#'     for kept markers, storing results in disk-based \code{big.matrix} objects.
#' }
#' Genotypes are centered by subtracting \code{ploidy * p2}, where \code{p2} is the mean genotype divided by ploidy.
#' Missing values are imputed with the marker's mean genotype.
#' Dominance coefficients are computed as:
#' \code{-2 * choose(ploidy, 2) * p^2 + 2 * (ploidy - 1) * p * geno - geno * (geno - 1)}.
#'
#' @examples
#' \dontrun{
#' # Example with a diploid dataset
#' result <- process_geno_matrix(
#'   filename = "insilico_hybrids_transposed.csv",
#'   ploidy = 2,
#'   dominance = TRUE,
#'   chunk_size = 5000,
#'   min_minor_allele = 10
#' )
#' print(result$id)
#' print(result$markers)
#' }
#'
#' @importFrom data.table fread setnames setDTthreads
#' @importFrom bigmemory big.matrix describe
#' @importFrom parallel detectCores
#' @importFrom foreach foreach %dopar%
#' @importFrom doParallel registerDoParallel stopImplicitCluster
#' @export
process_geno_matrix_transposed <- function(filename, ploidy, dominance = FALSE, chunk_size = 125000, min_minor_allele = 5) {
  # Ensure required packages are loaded
  if (!requireNamespace("foreach", quietly = TRUE)) {
    stop("Package 'foreach' is required but not installed. Please install it.")
  }
  if (!requireNamespace("doParallel", quietly = TRUE)) {
    stop("Package 'doParallel' is required but not installed. Please install it.")
  }
  
  message("Starting process_geno_matrix with filename: ", filename, ", ploidy: ", ploidy,
          ", dominance: ", dominance, ", chunk_size: ", chunk_size, ", min_minor_allele: ", min_minor_allele)
  
  # Configure data.table threading
  data.table::setDTthreads(threads = parallel::detectCores() - 1)
  
  # Initialize parallel backend
  message("Initializing parallel backend with ", parallel::detectCores() - 1, " cores...")
  doParallel::registerDoParallel(cores = parallel::detectCores() - 1)
  on.exit(doParallel::stopImplicitCluster()) # Ensure parallel backend is stopped
  
  # Validate inputs
  message("Validating inputs...")
  if (!file.exists(filename)) stop("File does not exist: ", filename)
  if (!is.numeric(ploidy) || ploidy < 2 || ploidy %% 2 != 0) stop("Ploidy must be an even positive number")
  if (!is.logical(dominance)) stop("dominance must be TRUE or FALSE")
  if (!is.numeric(chunk_size) || chunk_size < 1 || chunk_size %% 1 != 0) stop("chunk_size must be a positive integer")
  if (!is.numeric(min_minor_allele) || min_minor_allele < 0) stop("min_minor_allele must be non-negative")
  message("Input validation completed.")
  
  # Read header and determine columns
  message("Reading CSV header...")
  header <- data.table::fread(filename, nrows = 0)
  col_names <- names(header)
  if (col_names[1] != "hybrid") stop("First column must be 'hybrid'")
  all_markers <- col_names[-1]
  M <- length(all_markers)
  if (M == 0) stop("No markers found in CSV")
  message("Header processed. Number of markers (M): ", M)
  
  # Determine number of hybrids
  N <- data.table::fread(filename, select = 1, header = TRUE)$hybrid |> length()
  message("Number of hybrids (N): ", N)
  
  # First pass: Compute per-marker statistics in chunks of hybrids
  message("Starting first pass: computing per-marker statistics...")
  sum_geno <- numeric(M)
  count_geno <- numeric(M)
  count_above_01 <- numeric(M)
  count_below_09 <- numeric(M)
  names(sum_geno) <- names(count_geno) <- names(count_above_01) <- names(count_below_09) <- all_markers
  num_chunks <- ceiling(N / chunk_size)
  message("Number of chunks for first pass: ", num_chunks)
  
  # Parallelize first pass
  first_pass_results <- foreach::foreach(i = 1:num_chunks, .packages = c("data.table"), .combine = c, .errorhandling = "stop") %dopar% {
    start_idx <- (i - 1) * chunk_size + 1
    end_idx <- min(i * chunk_size, N)
    chunk_size_actual <- end_idx - start_idx + 1
    
    # Read chunk with numeric genotypes
    col_types <- c("character", rep("double", M))
    names(col_types) <- c("hybrid", all_markers)
    tryCatch({
      geno_chunk <- data.table::fread(filename,
                                      skip = start_idx,
                                      nrows = chunk_size_actual,
                                      header = TRUE,
                                      colClasses = col_types)
      data.table::setnames(geno_chunk, c("hybrid", all_markers))
    }, error = function(e) {
      stop("Error reading chunk ", i, " from CSV: ", conditionMessage(e))
    })
    
    # Check for markers with all NA values
    geno_cols_dt <- all_markers
    na_cols <- geno_cols_dt[sapply(geno_chunk[, .SD, .SDcols = geno_cols_dt], function(x) all(is.na(x)))]
    if (length(na_cols) > 0) {
      warning("Chunk ", i, ": Markers ", paste(na_cols, collapse = ", "), " contain non-numeric data; treating as NA")
    }
    
    # Compute sums, counts, and minor allele counts
    chunk_sum <- colSums(geno_chunk[, .SD, .SDcols = geno_cols_dt], na.rm = TRUE)
    chunk_count <- colSums(!is.na(geno_chunk[, .SD, .SDcols = geno_cols_dt]))
    chunk_count_above_01 <- colSums(geno_chunk[, .SD, .SDcols = geno_cols_dt] / ploidy > 0.1, na.rm = TRUE)
    chunk_count_below_09 <- colSums(geno_chunk[, .SD, .SDcols = geno_cols_dt] / ploidy < 0.9, na.rm = TRUE)
    
    # Garbage collection
    gc()
    
    # Return results as a named list
    list(list(sum = chunk_sum, count = chunk_count, count_above_01 = chunk_count_above_01, count_below_09 = chunk_count_below_09))
  }
  
  # Aggregate first pass results
  message("Aggregating first pass results...")
  for (res in first_pass_results) {
    sum_geno <- sum_geno + res$sum
    count_geno <- count_geno + res$count
    count_above_01 <- count_above_01 + res$count_above_01
    count_below_09 <- count_below_09 + res$count_below_09
  }
  
  # Compute allele frequencies and filter markers
  message("Computing allele frequencies and filtering markers...")
  mean_geno <- sum_geno / count_geno
  mean_geno[is.nan(mean_geno)] <- 0
  p2 <- mean_geno / ploidy
  n_minor <- ifelse(p2 <= 0.5, count_above_01, count_below_09)
  keep_markers <- n_minor >= min_minor_allele & count_geno > 0
  all_markers <- all_markers[keep_markers]
  sum_geno <- sum_geno[keep_markers]
  count_geno <- count_geno[keep_markers]
  mean_geno <- mean_geno[keep_markers]
  p2 <- p2[keep_markers]
  M_kept <- length(all_markers)
  if (M_kept == 0) stop("No markers meet min_minor_allele threshold")
  message("Number of markers after filtering: ", M_kept)
  
  # Initialize disk-based matrices
  message("Initializing disk-based matrices...")
  coeff <- bigmemory::big.matrix(nrow = N, ncol = M_kept, type = "double", init = 0,
                                 backingfile = "coeff.bin", descriptorfile = "coeff.desc")
  message("Additive coefficient matrix initialized. Dimensions: ", N, " rows x ", M_kept, " cols")
  if (dominance) {
    coeff.D <- bigmemory::big.matrix(nrow = N, ncol = M_kept, type = "double", init = 0,
                                     backingfile = "coeff.D.bin", descriptorfile = "coeff.D.desc")
    message("Dominance coefficient matrix initialized. Dimensions: ", N, " rows x ", M_kept, " cols")
  }
  
  # Second pass: Compute coefficients in chunks of individuals
  message("Starting second pass: filling coefficient matrices...")
  kept_marker_cols <- which(keep_markers)
  num_chunks <- ceiling(N / chunk_size)
  message("Number of chunks for second pass: ", num_chunks)
  
  # Parallelize second pass
  foreach::foreach(i = 1:num_chunks, .packages = c("data.table", "bigmemory")) %dopar% {
    start_idx <- (i - 1) * chunk_size + 1
    end_idx <- min(i * chunk_size, N)
    chunk_size_actual <- end_idx - start_idx + 1
    message("Chunk ", i, ": Processing rows ", start_idx, " to ", end_idx, " (", chunk_size_actual, " rows)")
    
    # Calculate column indices to select
    col_indices <- c(1, 1 + kept_marker_cols)
    
    # Read chunk with header=FALSE, skipping header line appropriately
    geno_chunk <- data.table::fread(filename,
                                    skip = 1 + (i - 1) * chunk_size,
                                    nrows = chunk_size_actual,
                                    header = FALSE)
    geno_chunk <- geno_chunk[, col_indices, with = FALSE]
    data.table::setnames(geno_chunk, c("individual", all_markers))
    geno_chunk[, (all_markers) := lapply(.SD, as.numeric), .SDcols = all_markers]
    
    message("Chunk ", i, ": fread() completed")
    
    # Impute missing values and compute centered coefficients
    geno_cols_dt <- all_markers
    centered_chunk <- geno_chunk[, .SD, .SDcols = geno_cols_dt]
    centered_chunk[, (geno_cols_dt) := lapply(.SD, function(x, marker) {
      ifelse(is.na(x), mean_geno[match(marker, all_markers)], x)
    }, marker = geno_cols_dt), .SDcols = geno_cols_dt]
    
    message("Chunk ", i, ": Imputation completed for centered_chunk")
    
    centered_chunk[, (geno_cols_dt) := lapply(seq_along(.SD), function(j) {
      .SD[[j]] - ploidy * p2[geno_cols_dt[j]]
    }), .SDcols = geno_cols_dt]
    
    message("Chunk ", i, ": Centering completed")
    
    # Compute dominance coefficients
    if (dominance) {
      dom_chunk <- geno_chunk[, .SD, .SDcols = geno_cols_dt]
      dom_chunk[, (geno_cols_dt) := lapply(seq_along(.SD), function(j) {
        x <- .SD[[j]]
        marker <- geno_cols_dt[j]
        geno <- ifelse(is.na(x), mean_geno[match(marker, all_markers)], x)
        p <- p2[match(marker, all_markers)]
        result <- -2 * choose(ploidy, 2) * p^2 + 2 * (ploidy - 1) * p * geno - geno * (geno - 1)
        if (length(result) != length(x)) {
          stop("Length mismatch in dominance for marker ", marker, ": expected ", length(x), ", got ", length(result))
        }
        result
      }), .SDcols = geno_cols_dt]
      message("Chunk ", i, ": Dominance coefficients computed")
    }
    
    # Assign to big.matrix
    coeff[start_idx:end_idx, ] <- as.matrix(centered_chunk)
    if (dominance) coeff.D[start_idx:end_idx, ] <- as.matrix(dom_chunk)
    
    # Garbage collection
    gc()
    
    # Log completion
    message("Chunk ", i, ": Completed processing ", chunk_size_actual, " hybrids.")
    
    NULL
  }
  
  # Return descriptors for disk-based matrices
  message("Returning results...")
  result <- list(coeff = bigmemory::describe(coeff), id = data.table::fread(filename, select = 1, header = TRUE)$hybrid, markers = all_markers)
  if (dominance) result$coeff.D <- bigmemory::describe(coeff.D)
  message("process_geno_matrix completed successfully.")
  return(result)
}
